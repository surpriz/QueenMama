// packages/database/prisma/schema.prisma

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl-arm64-openssl-3.0.x", "linux-musl-openssl-3.0.x", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============= USERS & ORGANIZATIONS =============

enum UserRole {
  USER
  ADMIN
}

enum AccountStatus {
  ACTIVE
  BLOCKED
  DELETED
}

model Customer {
  id        String   @id @default(cuid())
  clerkId   String?  @unique // Optional - for future Clerk migration
  email     String   @unique
  password  String   // Hashed password for custom auth
  firstName String?
  lastName  String?
  company   String?
  phone     String?  // Optional international phone number

  // Account management
  role          UserRole        @default(USER)
  status        AccountStatus   @default(ACTIVE)
  isVerified    Boolean         @default(false)

  // Email verification
  verificationToken           String?   @unique
  verificationTokenExpiresAt  DateTime?
  emailVerifiedAt             DateTime?

  // Password reset
  passwordResetToken          String?   @unique
  passwordResetTokenExpiresAt DateTime?

  // Stripe (pour paiements one-time uniquement)
  stripeCustomerId String?  @unique

  // Billing (pour futur usage)
  credits         Int      @default(0)
  creditsUsed     Int      @default(0)

  campaigns       Campaign[]
  payments        Payment[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([email])
  @@index([role])
  @@index([status])
}

// Enum MarketDifficulty pour la tarification dynamique
enum MarketDifficulty {
  EASY        // Marché facile, beaucoup de prospects
  MEDIUM      // Marché standard
  HARD        // Marché difficile, peu de prospects
  VERY_HARD   // Marché très niché
}

// Enum DepositStatus pour le suivi des dépôts de campagne
enum DepositStatus {
  PENDING           // En attente de dépôt
  CHECKOUT_CREATED  // Lien de paiement Stripe créé
  PAID              // Dépôt payé, campagne peut être activée
  FAILED            // Paiement échoué ou expiré
}

// ============= CAMPAIGNS =============

model Campaign {
  id          String   @id @default(cuid())
  customerId  String
  customer    Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)

  name        String
  description String?
  status      CampaignStatus @default(DRAFT)

  // ICP (Ideal Customer Profile)
  targetCriteria Json // { industries: [], companySize: [], locations: [], titles: [] }

  // Budget & Pricing (tarification dynamique)
  budget          Float
  pricePerLead    Float?  // Null jusqu'à validation par admin
  maxLeads        Int?    // Optional cap

  // Analyse du marché (rempli par admin)
  estimatedTam      Int?              // TAM estimé (nombre de prospects trouvés)
  marketDifficulty  MarketDifficulty? // Difficulté du marché
  adminNotes        String?           // Notes de l'admin sur l'analyse
  priceApprovedAt   DateTime?         // Date de validation du prix
  priceApprovedBy   String?           // ID de l'admin qui a validé

  // Système de dépôt et crédits (Stripe)
  depositStatus     DepositStatus @default(PENDING)
  depositPaidAt     DateTime?
  depositCheckoutId String?       // Stripe Checkout Session ID
  creditBalance     Int           @default(0)  // Crédits disponibles pour cette campagne

  // Email Sequence
  emailSequences  EmailSequence[]

  // Stats
  totalContacted  Int @default(0)
  totalReplies    Int @default(0)
  totalQualified  Int @default(0)
  totalPaid       Int @default(0)

  leads           Lead[]
  payments        Payment[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  startedAt DateTime?
  completedAt DateTime?

  @@index([customerId])
  @@index([status])
  @@index([depositStatus])
}

enum CampaignStatus {
  DRAFT          // Being configured
  PENDING_REVIEW // Waiting for admin approval
  WARMUP         // Domain warming phase
  ACTIVE         // Currently running
  PAUSED         // Temporarily stopped
  COMPLETED      // Finished
  CANCELED       // Canceled by user
}

model EmailSequence {
  id          String   @id @default(cuid())
  campaignId  String
  campaign    Campaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)

  step        Int      // 1, 2, 3...
  subject     String
  body        String   @db.Text
  delayDays   Int      // Days after previous email

  // Stats
  sent        Int @default(0)
  opened      Int @default(0)
  clicked     Int @default(0)
  replied     Int @default(0)

  @@index([campaignId])
}

// ============= LEADS =============

model Lead {
  id          String   @id @default(cuid())
  campaignId  String
  campaign    Campaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  customerId  String   // For quick access

  // Contact Info (encrypted in production)
  firstName   String
  lastName    String
  email       String
  company     String
  title       String
  linkedinUrl String?
  phone       String?

  // Enrichment data
  companySize     String?
  companyIndustry String?
  location        String?

  // Status & Qualification
  status          LeadStatus @default(CONTACTED)
  qualityScore    Int?       // 0-100 (AI-generated)
  sentiment       Sentiment? // POSITIVE, NEUTRAL, NEGATIVE

  // Interactions
  interactions    Interaction[]

  // Payment
  isRevealed      Boolean @default(false)
  revealedAt      DateTime?
  paidAmount      Float?
  paymentId       String?
  payment         Payment? @relation(fields: [paymentId], references: [id])

  // Pending unlock (pour auto-déblocage après recharge)
  pendingUnlock   PendingLeadUnlock?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([campaignId])
  @@index([customerId])
  @@index([status])
  @@index([email])
}

enum LeadStatus {
  CONTACTED      // Email sent
  OPENED         // Email opened
  REPLIED        // Replied to email
  INTERESTED     // Positive reply (AI-detected)
  QUALIFIED      // Manually qualified, ready to unlock
  PAID           // Customer paid to reveal contact
  NOT_INTERESTED // Negative reply
  BOUNCED        // Email bounced
  UNSUBSCRIBED   // Unsubscribed
}

enum Sentiment {
  POSITIVE
  NEUTRAL
  NEGATIVE
}

model Interaction {
  id          String   @id @default(cuid())
  leadId      String
  lead        Lead     @relation(fields: [leadId], references: [id], onDelete: Cascade)

  type        InteractionType
  content     String?  @db.Text // Email content, encrypted
  metadata    Json?    // { opened: true, clicked: true, links: [] }

  createdAt   DateTime @default(now())

  @@index([leadId])
  @@index([createdAt])
}

enum InteractionType {
  EMAIL_SENT
  EMAIL_OPENED
  EMAIL_CLICKED
  EMAIL_REPLIED
  EMAIL_BOUNCED
  LINKEDIN_VISITED
  PHONE_CALLED
}

// ============= PAYMENTS =============

model Payment {
  id              String   @id @default(cuid())
  customerId      String
  customer        Customer @relation(fields: [customerId], references: [id])

  // Relation campagne (pour dépôts et recharges)
  campaignId      String?
  campaign        Campaign? @relation(fields: [campaignId], references: [id])

  type            PaymentType
  amount          Float
  currency        String @default("EUR")

  // Stripe
  stripePaymentIntentId   String? @unique
  stripeInvoiceId         String?
  stripeCheckoutSessionId String? @unique  // Pour Checkout Sessions

  status          PaymentStatus @default(PENDING)

  // Related entities
  leads           Lead[]
  metadata        Json? // { leadIds: [], campaignId: "" }

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([customerId])
  @@index([campaignId])
  @@index([status])
  @@index([stripeCheckoutSessionId])
}

enum PaymentType {
  LEAD_UNLOCK       // Déblocage d'un lead (consommation de crédit)
  DEPOSIT           // Dépôt initial de garantie (2 leads)
  CREDIT_RECHARGE   // Recharge de crédits (5 ou 10 leads)
}

enum PaymentStatus {
  PENDING
  SUCCEEDED
  FAILED
  REFUNDED
  CANCELED
}

// ============= PENDING LEAD UNLOCKS =============

// Suivi des leads en attente de déblocage après recharge
model PendingLeadUnlock {
  id                      String   @id @default(cuid())
  leadId                  String   @unique
  lead                    Lead     @relation(fields: [leadId], references: [id], onDelete: Cascade)
  customerId              String
  campaignId              String
  stripeCheckoutSessionId String
  expiresAt               DateTime // 24h après création

  createdAt DateTime @default(now())

  @@index([stripeCheckoutSessionId])
  @@index([customerId])
  @@index([expiresAt])
}

// ============= JOBS & SYSTEM =============

model Job {
  id          String   @id @default(cuid())
  name        String   // e.g., "send-email-sequence"
  data        Json     // Job payload
  status      JobStatus @default(PENDING)
  attempts    Int      @default(0)
  maxAttempts Int      @default(3)
  error       String?  @db.Text

  scheduledAt DateTime?
  startedAt   DateTime?
  completedAt DateTime?

  createdAt DateTime @default(now())

  @@index([status])
  @@index([scheduledAt])
}

enum JobStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELED
}

model AuditLog {
  id        String   @id @default(cuid())
  userId    String   // Clerk ID
  action    String   // e.g., "campaign.created"
  entity    String   // e.g., "Campaign"
  entityId  String
  metadata  Json?
  ipAddress String?
  userAgent String?

  createdAt DateTime @default(now())

  @@index([userId])
  @@index([action])
  @@index([createdAt])
}
